

\chapter{Revisión Bibliográfica}

Existe una gran cantidad de aplicaciones que pueden ser modelas por TOP. Es por esto que la clase de problemas de enrutamiento de vehículos con ganancias es amplia. En el 2013, C. Archetti, M.G. Speranza, D. Vigo \cite{ArchettiSperanzaVigo} publicaron una revisión sobre esta clase de problemas. En este capítulo se sintetizan varias publicaciones y trabajos previos que encontré relacionados con el TOP.

\bigskip

La primera heurística propuesta para el TOP es un algoritmo de construcción simple introducido por Butt y Cavalier \cite{ButtCavalier} y probado en pequeñas instancias de tamaño con hasta 15 nodos. En su heurística \textit{MaxImp}, se asignan pesos a cada par de nodos de modo que cuanto mayor es el peso, más beneficioso es no solo visitar esos dos nodos, sino visitarlos en el mismo recorrido. Su peso depende de cuán beneficioso sean los nodos y las sumas de las distancias de ir y volver por esos nodos. Butt y Cavalier intrudujeron este problema con el nombre \textit{Multiple Tour Maximum Collection Problem}, que posteriormente fue nombrado TOP.

\bigskip

Los primeros que utilizaron el nombre TOP para referenciar el problema fueron Chao, Golden y Wasil (CGW) \cite{ChaoGoldenWasil} para resaltar la conexión con el más ampliamente estudiado caso de un solo vehículo (OP). En su trabajo utilizaron una heurística de construcción más sofisticada donde la solución inicial se refina a través de movimientos de los clientes, los intercambios y varias estrategias de reinicio. En este trabajo mencionan que TOP puede ser modelado como un problema de optimización multinivel. En el primer nivel, se debe seleccionar un subconjunto de puntos para que el equipo visite. En el segundo nivel, se asignan puntos a cada miembro del equipo. En el tercer nivel, se construye un camino a través de los puntos asignados a cada miembro del equipo. El algoritmo resultante se prueba en un conjunto de 353 instancias de prueba con hasta 102 clientes y hasta 4 vehículos.

\bigskip

El primer algoritmo exacto para TOP fue propuesto por Butt y Ryan \cite{ButtRyan}. Comienzan a partir de una formulación de partición configurada y su algoritmo hace un uso eficiente tanto de la generación de columnas como de la bifurcación de restricciones. Gracias a este nuevo algoritmo pudieron resolver instancias con hasta 100 clientes potenciales cuando las rutas incluyen solo unos pocos clientes cada uno. Más recientemente, Boussier et al. \cite{BoussierFeilletGendreau} presentaron un algoritmo de \textit{Branch and Price}. Gracias a diversos procedimientos de aceleración en el paso de generación de columnas, puede resolver instancias con hasta 100 clientes potenciales del gran conjunto de instancias de referencia propuestas en Chao et al. \cite{ChaoGoldenWasil}.

\bigskip

El algoritmo \textit{Tabu Search} (TS) demostró poder resolver TOP como es el caso del trabajo de Tang y Miller-Hooks (TMH) \cite{TangMillerHooks}. Su TS está incorporado en un \textit{Adaptive Memory Procedure} (AMP) que alterna entre vecindarios pequeños y grandes durante la búsqueda. La heurística de búsqueda tabú propuesta por TMH para el TOP se puede caracterizar en términos generales en tres pasos: inicialización, mejora de la solución y evaluación. Paso A, iniciación desde el AMP: dada la solución actual $s$ determinada en el AMP, establece los parámetros tabú a una pequeña etapa del vecindario en la que solo se explorará una pequeña cantidad de soluciones de vecindario. Paso B, mejora: en función de los parámetros tabú actuales y mediante procedimientos aleatorios y golosos, se generan soluciones en el vecindario de la solución actual $s$. En iteraciones selectas, la secuencia de cada una de estas soluciones de vecindario se mejora mediante procedimientos heurísticos. Paso C, evaluación: Se selecciona la mejor solución que no sea tabú entre los candidatos generados en el paso B. El estado tabú puede anularse si la mejor solución tabú es mejor que la mejor solución factible actual. Dependiendo del tamaño actual del vecindario y la calidad de la solución, se establece el parámetro del tamaño del vecindario en etapas grandes o pequeñas y regresa al paso A o al B. Como señala Golden et al. \cite{GoldenLaporteTaillard}, el AMP funciona de forma similar a los algoritmos genéticos, con la excepción de que la descendencia (en AMP, las nuevas soluciones iniciales) se puede generar a partir de más de dos padres. Sus resultados de experimentos computacionales realizados sobre el mismo conjunto de problemas de Chao et al. muestran que la técnica propuesta produce consistentemente soluciones de alta calidad superando las propuestas publicadas hasta el momento.

\bigskip

Archetti et al. \cite{ArchettiHertzSperanza} proponen dos variantes de un algoritmo de un TS generalizado y de un algoritmo llamado \textit{Variable Neighborhood Search} (VNS). El VNS parte de una solución titular $s$, desde donde se realiza un salto a una solución $s'$. Se llama salto porque se hace dentro de un vecindario más grande que el vecindario utilizado para la búsqueda tabú. Luego aplican una búsqueda tabú en $s'$ para tratar de mejorarla. La solución resultante $s''$ se compara luego con $s$. Si se sigue una estrategia VNS, entonces $s''$ se convierte en el nuevo titular solo si $s''$ es mejor que $s$. En la estrategia de búsqueda tabú generalizada, se establece $s = s''$ incluso si $s''$ es peor que $s$. Este proceso se repite hasta que se cumplan algunos criterios de detención.

\bigskip

Ke et al. \cite{KeArchettiFeng} proponen un \textit{Ant Colony Optimization} (ACO) que utiliza cuatro métodos diferentes para construir soluciones candidatas. El ACO pertenece a la clase de metaheurísticas basadas en una población de soluciones. Utiliza una colonia de hormigas, que están guiadas por rastros de feromonas e información heurística, para construir soluciones de forma iterativa para un problema. El procedimiento principal se puede describir de la siguiente manera: una vez que se inicializan todos los rastros y parámetros de feromonas, las hormigas construyen soluciones iterativamente hasta que se alcanza un criterio de detención. El procedimiento iterativo principal consta de dos pasos. En el primer paso, cada hormiga construye una solución de acuerdo con la regla de transición. Entonces se puede adoptar un procedimiento de búsqueda local para mejorar una o más soluciones. En el segundo paso, los valores de las feromonas se actualizan de acuerdo con una regla de actualización de feromonas. Un punto clave del ACO es construir soluciones candidatas, Ke et al. \cite{KeArchettiFeng} proponen cuatro métodos: secuencial, determinista-concurrente, aleatorio-concurrente y simultáneo.

\bigskip

Los autores Vansteenwegen et al. \cite{VansteenwegenSouffriauBergheOudheusden}, crearon un algoritmo compuesto donde primero construyen una solución y luego la mejoran con una combinación de búsquedas locales. Las búsquedas locales utilizadas son: \textit{Swap}, \textit{Replace}, \textit{Move}, \textit{Insert} y \textit{2-Opt}. Una vez que la solución es mejorada, si es la mejor encontrada hasta el momento la guardan. Luego tienen un método para encontrar nuevas soluciones partiendo de una solución, quitándole destinos a las rutas y así poder explorar distintas opciones.

\bigskip

Souffriau et al. \cite{SouffriauVansteenwegenBergheOudheusden} combinan un \textit{Greedy Randomised Adative Search Procedure} (GRASP) con un \textit{Path Relinking} (PR) para resolver el TOP. Su algoritmo a grandes rasgos consta de una iteración de cuatro partes que se detiene una vez que no encuentra una mejor solución luego de una determinada cantidad de iteraciones. El primer paso es el de la construcción de una solución utilizando GRASP. Luego se realiza una búsqueda local donde aplican \textit{2-Opt}, \textit{Swap}, \textit{Insert} y \textit{Replace}. En el tercer paso se hace el PR entre la solución construida y las soluciones del conjunto de elite. En el último paso se actualiza el conjunto de soluciones de elite. Si el conjunto de elite no esta completo aún, se inserta la mejor solución obtenida en la iteración. En caso de que el conjunto de elite este completo, si la peor solución de elite es superada por la mejor solución de la iteración actual, se reemplazan.

\bigskip

Bouly et al. \cite{BoulyDangMoukrim} idearon un \textit{Memetic Algorithm} (MA) para resolver el TOP. Los MA son una combinación de un algoritmo genético y técnicas de búsqueda local. En su trabajo usan una codificación indirecta simple que denotan como un recorrido gigante, y un procedimiento de división óptima como el proceso de decodificación. Se dice que una codificación es indirecta si se necesita un procedimiento de decodificación para extraer soluciones de los cromosomas. El procedimiento de división que propusieron es específico del TOP. Sus resultados fueron muy buenos y en cinco instancias del benchmark de problemas superaron al mejor resultado obtenido en la literatura al momento de su publicación.

\bigskip

Dang et al. \cite{DangGuibadjMoukrim} proponen un \textit{Particle Swarm Optimization based Memetic Algorithm} (PSOMA) para resolver el TOP. Su algoritmo PSOMA provee de soluciones de alta calidad para el TOP. El algoritmo está relativamente cerca del MA propuesto en Bouly et al. \cite{BoulyDangMoukrim} y presenta los mismos componentes básicos, como la técnica de división de rutas, el inicializador de población y la vecindad de la búsqueda local. Sin embargo, el esquema global se ha modificado por una optimización de enjambre de partículas. El \textit{Particle Swarm Optimization} (PSO) es una de las técnicas de inteligencia de enjambre con la idea básica de simular la inteligencia colectiva y el comportamiento social de los animales salvajes.

\bigskip

Ferreira et al. \cite{FerreiraQuintasOliveiraPereiraDias} implementan un \textit{Genetic Algorithm} (GA) para resolver TOP. Su algoritmo consiste básicamente de tres componentes. El más elemental, llamado cromosoma, representa un conjunto de vehículos y sus rutas. El segundo componente es su proceso de evolución, responsable de hacer el cruzamiento y mutaciones dentro de una población. Su último componente es el algoritmo responsable de controlar el proceso evolutivo, asegurándose que los cromosomas sean válidos respecto de las restricciones de la instancia del TOP. En su proceso de cruzamiento se toman dos cromosomas y generan dos nuevos cromosomas utilizando aleatoriamente rutas de los cromosomas originales. Sus resultados fueron buenos, pero son superados por los resultados de Dang et al. \cite{DangGuibadjMoukrim} y Bouly et al. \cite{BoulyDangMoukrim}.

\bigskip

Esos fueron los trabajos encontrados en mi investigación sobre trabajos previos. Hay algunos que implementan algoritmos genéticos pero ninguno que implemente un \textit{Biased Random Key Generation Algorithm} (BRKGA). De entre todos los trabajos mencionados decidí comparar mi resultados con los obtenidos por el MA de Bouly et al. \cite{BoulyDangMoukrim}, el VNS\textsubscript{slow} de Archetti et al. \cite{ArchettiHertzSperanza} y el ACO\textsubscript{seq} de Ke et al. \cite{KeArchettiFeng} por que estos trabajos obtuvieron muy buenos resultados y plantean algoritmos diversos entre si.









