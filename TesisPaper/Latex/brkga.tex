
\chapter{Biased Random Key Genetic Algorithm}

\section{Algoritmos Genéticos}

Los \textit{Genetic Algorithims} (GA), \cite{Goldberg} aplican el concepto de supervivencia del más apto para encontrar soluciones óptimas o casi óptimas a los problemas de optimización combinatoria. Se hace una analogía entre una solución y un individuo en una población. Cada individuo es un cromosoma que codifica una solución. Un cromosoma consiste en una cadena de genes. Cada gen puede tomar un valor, llamado alelo, de algún alfabeto. Los cromosomas tienen asociado a ellos un nivel de condición física que está correlacionado con el correspondiente valor de la función objetivo de la solución que codifica. Los algoritmos genéticos manejan un conjunto de individuos que forman una población, a lo largo de varias generaciones. En cada generación se crea una nueva población con individuos provenientes de tres fuentes distintas. La primer fuente de individuos es el conjunto de soluciones elite, es decir las de mejor condición física. La segunda fuente de individuos provienen del \textit{crossover} (apareamiento), el \textit{crossover} es el método a través por el cual se obtiene un nuevo individuo a partir de dos individuos de la generación anterior. Por último se completa la nueva generación con individuos mutantes. Los mutantes son individuos generados al azar con el fin de escapar de atrapamientos en mínimos locales y diversificar la población. El concepto de supervivencia del más apto puede aparecer en los algoritmos genéticos de varias formas, dependiendo de la implementación en particular. Generalmente el conjunto de soluciones de elite pasan directamente a la nueva generación. Además en el método de apareamiento, cuando los individuos son seleccionados para aparearse y producir descendencia, aunque los individuos sean seleccionados al azar, aquellos con mejor aptitud física tienen mayor probabilidad de ser elegidos para generar descendientes y mayor probabilidad de transmitir sus genes a sus hijos.

\section{Random Key Genetic Algorithms}

El \textit{Random Key Genetic Algorithms} (RKGA) fue introducido por Bean en \textit{Genetic algorithms and random keys for sequencing and optimization.} \cite{Bean}. En RKGA, los cromosomas son representados por un vector de números reales generados al azar en el intervalo [0, 1]. El decodificador es el responsable de convertir un cromosoma en una solución del problema de optimización combinatoria para el cual se puede calcular su valor objetivo o aptitud física. Los algoritmos RKGAs evolucionan una población de vectores de claves aleatorios sobre una serie de iteraciones llamadas generaciones. La población inicial se compone de $p_t$ vectores de claves aleatorias. Cada alelo se genera independientemente al azar en el intervalo real [0, 1]. Después de calcular la aptitud de cada individuo por el decodificador, la población se divide en dos grupos de individuos. Un pequeño grupo de individuos de élite $p_e$, es decir, aquellos con mejores valores de aptitud individual. El segundo el conjunto remanente de $p_t-p_e$ no elite individuos donde $p_e<p_t-p_e$, es decir el conjunto de elite es menor en tamaño al conjunto de no elite. Con el fin de evolucionar a la población, un RKGA utiliza una estrategia elitista ya que todos los individuos de élite de la generación $k$ se copian sin cambios a la generación $k + 1$. Esta estrategia mantiene un seguimiento de las buenas soluciones encontradas durante las iteraciones del algoritmo que resulta en una heurística de mejora monotónica. En los RKGAs, se generan individuos mutantes a partir de un vector de claves aleatorias, de la misma manera que los individuos de la población inicial. Con la población $p_e$ (elites) y la población $p_m$ (mutantes), un conjunto adicional de individuos $p_t - p_e - p_m$ es requerido para completar la generación $k+1$. Esto se hace generando una descendencia mediante el proceso de \textit{crossover}, en el RKGA los padres son elegidos al azar sobre toda la población y cada padre tiene la misma probabilidad de transmitir sus genes al individuo resultante.

\section{Biased Random Key Genetic Algorithms}\label{sec:brkga}

El \textit{Biased Random Key Genetic Algorithms} (BRKGA), difiere del RKGA en la forma en que los padres son seleccionados para el \textit{crossover}. En un BRKGA, cada elemento se genera combinando un elemento seleccionado al azar del conjunto de elite y el otro de la partición no elite. En algunos casos el segundo padre se selecciona de toda la población mientras sean dos padres diferentes. Se permite la repetición en la selección de un padre y, por lo tanto, un individuo puede producir más de un hijo. Como el tamaño del conjunto de elite es mayor al conjunto de no elite ($p_e < p_t - p_e$), la probabilidad de que un individuo de élite sea seleccionado para el apareamiento es mayor que la de un individuo no élite. Por lo tanto un individuo de élite tiene un mayor probabilidad de transmitir sus genes a generaciones futuras. Otro factor que contribuye a este fin es el \textit{parameterized uniform crossover} (Spears y DeJong \cite{SpearsDeJong}), el mecanismo utilizado para implementar el apareamiento en BRKGAs. Sea $\rho_e > 0,5$ la probabilidad de que un descendiente herede el alelo de su padre de elite. Sea $n$ el número de cromosomas de un individuo, para $i =1,...,n$ el i-ésimo alelo $c_i$ del descendiente $c$, este alelo $c_i$ toma el valor del i-ésimo alelo $e_i$ del padre de elite $e$ con una probabilidad $\rho_e$ y el valor del $e'_i$ del padre no elite con probabilidad $1-\rho_e$. Este proceso se puede ver en la figura \ref{fig:biasCrossover}. De esta manera, es más probable que la descendencia herede características del padre de élite que las del padre no de élite. Dado que asumimos que cualquier vector de clave aleatoria puede ser decodificado en una solución, entonces el descendiente del \textit{crossover} siempre decodifica en una solución válida del problema de optimización combinatoria.


% \adjustbox{
    % min size={\mywidth}{\myheight},
    % Clip*={0.5\width - 0.5\mywidth} {0.5\totalheight - 0.5\myheight}
          % {0.5\width + 0.5\mywidth} {0.5\totalheight + 0.5\myheight}
% }{
% \begin{figure}[h]
	% \caption{Bias crossover}
	% \centering
	% \includegraphics[max size={\mywidth}{\myheight}]{BiasCrossover}
	% \label{fig:biasCrossover}
% \end{figure}    
% }

\begin{figure}[h]
	\caption{bias crossover}
	\centering
	\includegraphics[width=15cm]{BiasCrossover}
	\label{fig:biascrossover}
\end{figure}

\bigskip

En la figura \ref{fig:evolucion} se puede observar como funciona la evolución. Los individuos son ordenados por su aptitud y marcados como elite y no-elite. Vemos como los individuos de elite pasan directamente a la siguiente generación. Un porcentage pequeño de la nueva generación es conformado por individuos mutantes, generados al azar como la población inicial. Y complementa la nueva poblacion los individuos generados por el \textit{crossover} entre un individuo elite con un individuo no elite. 

\bigskip

En la figura \ref{fig:biasCrossover} se puede observar como funciona el \textit{parameterized uniform crossover}. El primer vector de cromosomas es de un individuo de elite, el segundo vector de cromosomas es de un individuo no elite. Se decide que cromosomas tomara el individuo hijo utilizando un vector de reales aleatorio del mismo tamaño que los vectores de cromosomas. En este ejemplo se utiliza un $\rho_e = 0.70$, de este modo la descendencia se asemejara mas al padre de elite.

\begin{figure}[h]
	\caption{Evolución de una población}
	\centering
	\includegraphics[width=16cm]{EvolucionPoblacion}
	\label{fig:evolucion}
\end{figure}

\section{Decodificador del BRKGA}

Una caracterisitca importante para mencionar del BRKGA es que que el decodificador es el único modulo del algoritmo que requiere conocimiento del dominio del problema. El decodificador transforma un vector aleatorio de enteros en una instancia de una solución del problema. Es un adaptador, por lo tanto si hacemos un decodificador para otro problema podríamos reutilizar el modulo de BRKGA.

\bigskip

En el caso de mi impementación del BRKGA entre cada generación se ejecutan unas heuristicas de busqueda local sobre las mejores soluciones de la población. Como estas heuristicas trabajan sobre una instancia de la solución, requiere que exista un objeto codificador. Es decir, es decir un algoritmo capas de convertir una solución del problem en un vector de enteros aleatorios. De este modo, una vez que se mejora una solución, podemos actualizar su vector aleatorio que lo representa y seguir el curso del BRKGA. 

