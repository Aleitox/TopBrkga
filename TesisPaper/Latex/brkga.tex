
\chapter{Biased Random Key Genetic Algorithm}

\section{Algoritmos Genéticos}

Los \textit{Genetic Algorithims} (GA), \cite{Goldberg} aplican el concepto de supervivencia del más apto para encontrar soluciones óptimas o casi óptimas a los problemas de optimización combinatoria. Se hace una analogía entre una solución y un individuo en una población. Cada individuo es un cromosoma que codifica una solución. Un cromosoma consiste en una cadena de genes. Cada gen puede tomar un valor, llamado alelo, de algún alfabeto. Los cromosomas tienen asociado a ellos un nivel de condición física que está correlacionado con el correspondiente valor de la función objetivo de la solución que codifica. Los algoritmos genéticos manejan un conjunto de individuos que forman una población, a lo largo de varias generaciones. En cada generación se crea una nueva población con individuos provenientes de tres fuentes distintas. La primer fuente de individuos es el conjunto de soluciones elite, es decir las de mejor condición física. La segunda fuente de individuos provienen del \textit{crossover} (apareamiento), el \textit{crossover} es el método a través por el cual se obtiene un nuevo individuo a partir de dos individuos de la generación anterior. Por último se completa la nueva generación con individuos mutantes. Los mutantes son individuos generados al azar con el fin de escapar de atrapamientos en mínimos locales y diversificar la población. El concepto de supervivencia del más apto puede aparecer en los algoritmos genéticos de varias formas, dependiendo de la implementación en particular. Generalmente el conjunto de soluciones de elite pasan directamente a la nueva generación. Además en el método de apareamiento, cuando los individuos son seleccionados para aparearse y producir descendencia, aunque los individuos sean seleccionados al azar, aquellos con mejor aptitud física tienen mayor probabilidad de ser elegidos para generar descendientes y mayor probabilidad de transmitir sus genes a sus hijos.

\section{Random Key Genetic Algorithms}

El \textit{Random Key Genetic Algorithms} (RKGA) fue introducido por Bean en \textit{Genetic algorithms and random keys for sequencing and optimization.} \cite{Bean}. En RKGA, los cromosomas o individuos son representados por un vector de números reales generados al azar en el intervalo [0, 1]. El decodificador es el responsable de convertir un cromosoma en una solución del problema de optimización combinatoria, para el cual se puede calcular su valor objetivo o aptitud física. Los algoritmos RKGAs evolucionan una población de vectores de claves aleatorios sobre una serie de iteraciones llamadas generaciones. La población inicial se compone de $p_t$ vectores de claves aleatorias. Todos los vectores contienen la misma cantidad de claves aleatorias llamadas alelos. Cada alelo se genera independientemente al azar en el intervalo real [0, 1]. Después de obtener las soluciones utilizando el decodificador, se calcula la aptitud de cada individuo de la población, luego la población se divide en dos grupos de individuos. Se obtiene por un lado un pequeño grupo de individuos de élite, es decir aquellos con mejores valores de aptitud física Denotamos el tamaño del conjunto de elite como $p_e$. El segundo grupo se conforma por todos los individuos restantes, es el grupo de no-elite y su tamaño es $p_t-p_e$. Todo individuo del conjunto de elite tiene mayor aptitud fisica que cualquier individuo del conjunto de no-elite y el tamaño del conjunto de elite es menor al tamaño del conjunto de no-elite, es decir $p_e<p_t-p_e$. Con el fin de evolucionar a la población, un RKGA utiliza una estrategia elitista ya que todos los individuos de élite de la generación $k$ se copian sin cambios a la generación $k + 1$. Esta estrategia mantiene un seguimiento de las buenas soluciones encontradas durante las iteraciones del algoritmo que resulta en una heurística de mejora monotónica. En los RKGAs, se generan individuos mutantes a partir de un vector de claves aleatorias, de la misma manera que los individuos de la población inicial. Con la población $p_e$ (elites) y la población $p_m$ (mutantes), un conjunto adicional de individuos $p_t - p_e - p_m$ es requerido para completar la generación $k+1$. Esto se hace generando una descendencia mediante el proceso de \textit{crossover}, en el RKGA los padres son elegidos al azar sobre toda la población y cada padre tiene la misma probabilidad de transmitir sus genes al individuo resultante.

\section{Biased Random Key Genetic Algorithms}\label{sec:brkga}

El \textit{Biased Random Key Genetic Algorithms} (BRKGA), difiere del RKGA en la forma en que los padres son seleccionados para el \textit{crossover}. En un BRKGA, cada elemento se genera combinando un elemento seleccionado al azar del conjunto de elite y el otro de la partición no elite. En algunos casos el segundo padre se selecciona de toda la población mientras sean dos padres diferentes. Se permite la repetición en la selección de un padre y, por lo tanto, un individuo puede producir más de un hijo. Como el tamaño del conjunto de elite es menor al conjunto de no-elite ($p_e < p_t - p_e$), la probabilidad de que un individuo de elite sea seleccionado para el apareamiento es mayor que la de un individuo no-elite. Por lo tanto un individuo de elite tiene un mayor probabilidad de transmitir sus genes a generaciones futuras. Otro factor que contribuye a este fin es el \textit{parameterized uniform crossover} (Spears y DeJong \cite{SpearsDeJong}), el mecanismo utilizado para implementar el apareamiento en BRKGAs. Sea $\rho_e > 0,5$ la probabilidad de que un descendiente herede el alelo de su padre de elite. Sea $n$ el número de alelos de un individuo, para $i =1,...,n$ el i-ésimo alelo $c_i$ del descendiente $c$, este alelo $c_i$ toma el valor del i-ésimo alelo $e_i$ del padre de elite $e$ con una probabilidad $\rho_e$ y el valor del $e'_i$ del padre no-elite con probabilidad $1-\rho_e$. Este proceso se puede ver en la figura \ref{fig:biasCrossover}. Como $\rho_e > 0,5$, luego $\rho_e > 1 - \rho_e$, por lo tanto es más probable que el individuo resultante herede características del padre de élite que las del padre de no-élite. Dado que asumimos que cualquier vector de clave aleatoria puede ser decodificado en una solución, entonces el cromosoma resultante del \textit{crossover} siempre decodifica en una solución válida del problema de optimización combinatoria.


% \adjustbox{
    % min size={\mywidth}{\myheight},
    % Clip*={0.5\width - 0.5\mywidth} {0.5\totalheight - 0.5\myheight}
          % {0.5\width + 0.5\mywidth} {0.5\totalheight + 0.5\myheight}
% }{
% \begin{figure}[h]
	% \caption{Bias crossover}
	% \centering
	% \includegraphics[max size={\mywidth}{\myheight}]{BiasCrossover}
	% \label{fig:biasCrossover}
% \end{figure}    
% }

\begin{figure}[h]
	\caption{bias crossover}
	\centering
	\includegraphics[width=15cm]{BiasCrossover}
	\label{fig:biasCrossover}
\end{figure}

\bigskip

En la figura \ref{fig:evolucion} se puede observar como funciona la evolución. Los individuos son ordenados por su aptitud y marcados como elite y no-elite. Vemos como los individuos de elite pasan directamente a la siguiente generación. Un porcentage pequeño de la nueva generación es conformado por individuos mutantes, generados al azar como la población inicial. Y complementa la nueva población los individuos generados por el \textit{crossover} entre un individuo elite con un individuo no-elite. 

\bigskip

En la figura \ref{fig:biasCrossover} se puede observar como funciona el \textit{parameterized uniform crossover}. El primer vector de alelos es de un individuo de elite, el segundo vector de alelos es de un individuo no-elite. Se decide que alelos tomará el individuo resultante utilizando un vector de reales aleatorio del mismo tamaño que los vectores de alelos. Los reales aleatorios toman un valor real en el intervalo [0,1]. En este ejemplo se utiliza un $\rho_e = 0.70$ incrementando la probabilidad de que el cromosoma resultante obtenga los alelos del cromosoma elite.

\begin{figure}[h]
	\caption{Evolución de una población}
	\centering
	\includegraphics[width=16cm]{EvolucionPoblacion}
	\label{fig:evolucion}
\end{figure}

\section{Decodificador del BRKGA}

Una característica importante para mencionar del BRKGA es que el decodificador es el único modulo del algoritmo que requiere conocimiento del dominio del problema. El decodificador transforma un vector de enteros aleatorios en una instancia de una solución del problema. El decodificador funciona como un adaptador, por lo tanto si hacemos un decodificador para otro problema podríamos reutilizar el modulo de BRKGA.

\bigskip

En el caso de esta implementación del BRKGA, entre cada generación se ejecuta una búsqueda local sobre las mejores soluciones de la población. Como estas búsquedas locales trabajan con una solución decodificada, requiere que exista un objeto codificador para actualizar el vector aleatorio de enteros de la solución mejorada. Es decir, un algoritmo capas de convertir una solución del problema en un vector de enteros aleatorios. De este modo, una vez que se mejora una solución, se actualiza su vector de enteros aleatorios que lo representa y luego sigue el curso normal del BRKGA. 

